<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[30 Days of Code]]></title>
    <url>%2F2018%2F03%2F20%2F30-Days-of-Code%2F</url>
    <content type="text"><![CDATA[Summary of my everyday learnings through HackerRank 30 Days of Code, mainly in Java.Update: Day 8: Dictionaries and Maps Day 8: Dictionaries and MapsMap简单方法存储键值对，一对一对存，而且要保证键的唯一性，无序 添加 12put(K key, V value)，返回这个键对应的原来的值。同样的键，新值会覆盖旧值。putAll(Map&lt;? extends K,? extends V&gt; m) 删除 12clear()remove(Object key) 判断 123containsValue(Object value)containsKey(Object key)isEmpty() 获取 123get(Object key)size()values() !– HashTable：底层是哈希表数据结构，不可以存入null键和null值的情况。该集合是线程同步的，效率低!– HashMap：底层是哈希表数据结构，允许使用null键null值。线程不同步，效率高!– TreeMap：底层是二叉树数据结构，线程不同步，可以给map集合中的键排序Set集合底层使用了Map集合 Demo11234567891011121314151617181920212223242526272829303132import java.util.*;class MapDemo&#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素, 返回这个键对应的原来的值。同样的键，新值会覆盖旧值。 System.out.println("put 01-apple: " + map.put("01", "apple")); //put 01-apple: null System.out.println("put 01-new apple: " + map.put("01", "new apple")); //put 01-new apple: Mike map.put("02", "banana"); map.put("03", "grape"); //判断 System.out.println("containsKey: " + map.containsKey("02")); //return true //获取：可以通过get返回值是否为空来判断键是否存在 System.out.println("get: " + map.get("02")); //return banana System.out.println("get: " + map.get("022")); //return null //获取map中所有的值 Collection&lt;String&gt; coll = map.values(); //删除 System.out.println("remove: " + map.remove("02")); //return banana System.out.println("remove: " + map.remove("022")); //return null //打印 System.out.println(map); //&#123;01=new apple, 03=grape&#125; System.out.println(coll); //[new apple, grape] &#125;&#125; 重点：两种取出方法 entrySet() Returns a Set view of the mappings contained in this map Set&lt;Map.Entry&lt;K,V&gt;&gt; keySet() Returns a Set view of the keys contained in this map. Set 取出所有的键到Set中，通过迭代方式取出所有的键，然后再get获取每一个键对应的值图示keySet()Demo2123456789101112131415161718192021222324252627282930import java.util.*;class MapDemo2&#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put("01", "apple"); map.put("02", "banana"); map.put("03", "grape"); map.put("04", "pear"); //先获取所有键的集合 //Set&lt;键的类型&gt; 集合名字 = map.keySet() Set&lt;String&gt; fruitKeySet = map.keySet(); //获取Set迭代器 Iterator&lt;String&gt; it = fruitKeySet.iterator(); while(it.hasNext())&#123; String key = it.next(); System.out.println("Fruit key: " + key + " "); //Fruit key: 01 Fruit key: 02 Fruit key: 03 Fruit key: 04 //有了键就可以用Map的get()获取值 String value = map.get(key); System.out.println(key + "--" + value); //01--apple 02--banana 03--grape 04--pear &#125; &#125;&#125; Day 2: OperatorsMath.round() returns a double123double percent = (tip_percent + tax_percent)/100.0;int total = (int)Math.round(meal_cost * (1 + percent));System.out.println("The total meal cost is " + total + " dollars."); To Do: Round to 2 decimals In other languages Day 1: Data Types1. Different data type uses different reading methods.123int a = scan.nextInt(); //read next intdouble b = scan.nextDouble(); //read next doubleString c = scan.nextLine(); //read next line as String 2. nextInt(), nextDouble() methods do not consume \nFor example (This does not work.)12345678910111213int i = 4;double d = 4.0;String s = "HackerRank ";Scanner scan = new Scanner(System.in);/* Read and save an integer, double, and String to your variables.*/int a = scan.nextInt();double b = scan.nextDouble();String c = scan.nextLine();System.out.println(a + i);System.out.println(b + d);System.out.println(s + c); //only print s Input:12355.0test Output:1299.0 It is not able to reach the string input. Because nextInt(); reads the integer, but not the “\n”. Then nextLine() reads “\n”, and treats it as the input for c.The input with \n is1235\n5.0\ntest\n 因为nextInt()读入一个整数，但是不会读入这个整数后面的换行符\n。而这时nextLine()开始读，读到了换行符，这个换行符是之前那个整数后面的换行符。nextLine()继续这一行，发现换行符后面没东西了，所以返回了换行而已，并没有接下去读“test”。Solution:1234//Now each read consumes \nint a = Integer.parseInt(scan.nextLine());double b = Double.parseDouble(scan.nextLine());String c = scan.nextLine(); Summary Different data type uses different reading methods. nextInt(), nextDouble() do not consume \n. Reference:Scanner is skipping nextLine() after using next() or nextFoo()?Day 1: Data Types Day 0: Hello WorldRead from stdin:1Scanner scan = new Scanner(System.in); Read next:1234scan.next(); // returns the next token of inputscan.hasNext(); // returns true if there is another token of input (false otherwise)scan.nextLine() // returns the next LINE of inputscan.hasNextLine(); // returns true if there is another line of input When finish reading, close it to avoid a resource leak.1scan.close(); Example1234Scanner scan = new Scanner(System.in); // open scannerString s = scan.next(); // read the next token and save it to 's'scan.close(); // close scannerSystem.out.println(s); // print 's' to System.out, followed by a new line Reference: Day 0: Hello, World.]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Market Size 市场估计问题]]></title>
    <url>%2F2018%2F03%2F19%2FMarket-Size-%E5%B8%82%E5%9C%BA%E4%BC%B0%E8%AE%A1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[讨论市场估计问题中的两个类型：问具体数字；问服务的次数，并分别举例说明运算逻辑和过程。 分类根据这个回答，分为两种问题。 第一种：问具体数字。电商一年卖多少本书？ 第二种：问服务的次数。北京多少加油站？ 公式 第一种问题考虑角度：供应/需求 （Supply/Demand)从需求角度：数量 = 消费人群 × 消费频率 × 单位时间 第二种考虑角度：数量 =（单位时间内）服务的总次数 ÷ 频 举例第一种举例：电商一年大约卖多少本书？公式：书总数量（本）= ①用户总数（人）× ②书数量（本/人/年）× 1（年） 消费人群：电商用户（未知） 消费频率：一位电商用户一年买书的数量（未知） 单位时间：一年（已知） 简单来看：假设电商只有1位用户，这位用户每月买1本书。那么在一年内（12个月），这位用户买了 12 × 1 = 12 本书。也就是说，电商这一年内卖出了12本书，因为它只有这一位用户。（很简单的情况） 分步： 电商有多少用户？① 电商用户总数 = 中国网民总数 x 电商网站的市场比例 中国网民总数 = 7亿 = 7 × 10^8 （人） 假设 电商网站的市场比例 = 30% 则 ① 电商用户总数 = 7 × 10^8 × 30% = 2.1 × 10^8 （人） 一位电商用户一年买书的数量？② 一位电商用户一年买书的数量 = 一位电商用户一月买书的数量 × 12 （月） 假设平均每人每月买0.5本，即两个月买一本（因为现在人们很少买书了╮(╯▽╰)╭） 则 ② 书数量（本/人/年）= 书数量（本/人/月）× 12（月/年）= 0.5 × 12 = 6（本/人/年） 单位时间 = 1 年 结论结合 ①②： 书总数量（本）= 用户总数（人）× 书数量（本/人/年）× 1（年） 书总数量（本）= 2.1 × 10^8 × 6 × 1 = 1.26 × 10^9 （本）即：电商一年大约卖12.6亿本书。 第二种举例：美国有多少加油站？公式：加油站总数（个） = ①（单位时间内）汽车加油总次数（次）÷ ②（单位时间内）每个加油站加油总次数（次/个）简单来看，一天24小时中，假设全国汽车总共加油了10次，每个加油站在这天内总共被使用了5次，那么全国有10 ÷ 5 = 2 个加油站。 分步：以下计算都是在单位时间内，单位时间是10天 单位时间内，全国总共加油多少次？① 汽车加油总次数（次）= 加油次数（次/辆）× 汽车总数（辆） 加油次数（次/辆）：假设一辆车平均10天加一次油。即单位时间 = 10天，加油次数 = 1（次/辆/10天） 汽车总数（辆） 以家庭为单位，汽车总数（辆）= 汽车数量（辆/家）× 家庭数量（家） 假设每家平均1.5辆车。 每5人算一个家庭。美国人口约为3亿，则家庭数量 = 美国人口（人）÷ 5（人/家）= 3 × 10^8 ÷ 5 = 6 × 10^7 （家） 则汽车总数（辆） = 汽车数量（辆/家）× 家庭数量（家）= 1.5 × 6 × 10^7 = 9 × 10^7（辆） 所以：① 汽车加油总次数（次）= 加油次数（次/辆）× 汽车总数（辆）= 1 × 9 × 10^7 = 9 × 10^7（次） 单位时间内，每个加油站加油总次数？意思就是，假设一个加油站里有一台加油机，这台加油机每1小时被使用一次，一天有24小时，那么它这天总共被使用了24次。这个加油站也就被使用了24次。注意使用概率：并不是全国所有加油站都有机会被使用。偏远地区使用频率很低。所以这里假设有每个加油站有80%的概率被光顾。 ② 每个加油站加油总次数（次/个）= 使用概率 × 加油机数量（台/个）× 使用次数（次/台/天） 假设使用概率为80% 假设每个加油站有6台加油机。 假设每3小时一台加油机被使用一次，则一天24小时中这台加油机被使用了8次（24/8=3） 所以 ② 每个加油站加油总次数（次/个）= 使用概率 × 加油机数量（台/个）× 使用次数（次/台/天）= 80% × 6 × 8 = 38.4（次/个/天） 单位时间内，每个加油站加油总次数为38.4 × 10（天）= 384 ≈ 400（次/个） 结论结合 ①②：加油站总数（个） = ①（单位时间内）汽车加油总次数（次）÷ ②（单位时间内）每个加油站加油总次数（次/个）加油站总数（个）= 9 × 10^7 ÷ 400 = 2.25 × 10^5 = 225,000（个）即：美国大约有22.5万个加油站。 ​网上查到资料说美国大概有168,000个加油站（2004），数量级是一致的。Reference: market size 估算的一类问题应该怎么思考？ - 林梓默的回答 - 知乎]]></content>
      <categories>
        <category>Case Study</category>
      </categories>
      <tags>
        <tag>Market Size</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Common Commands]]></title>
    <url>%2F2018%2F03%2F19%2FHexo-Common-Commands%2F</url>
    <content type="text"><![CDATA[Hexo common commands for blog post. Create a new post 创建一个新的文章$ hexo new &quot;new post&quot; View site static 发布前预览$ hexo s Clean cache file 清理缓存（如果修改了格式）$ hexo clean Generate and deploy files 发布hexo g -d]]></content>
  </entry>
</search>
