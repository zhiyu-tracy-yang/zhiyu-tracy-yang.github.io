<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Retail Versus E-Commerce]]></title>
    <url>%2F2018%2F03%2F30%2FRetail-Versus-E-Commerce%2F</url>
    <content type="text"><![CDATA[美国实体零售店对抗电商亚马逊的三种方法Three methods that retails stop Amazon from killing stores. Method 1. Controlling costs That’s because a dollar saved is a dollar earned in profit, whereas a dollar raised in revenue only increases profit by a percentage (the profit margin). Method 2. Becoming a destinationOnline shops are not able to provide physically shopping experience. If retailers can focus on experience-oriented shops, they can attract customers. Method 3. DifferentiationOnline shops have costs in shipping. I remember the high shipping cost when we bought IKEA furnitures. If retailers can satisfy customers’ needs without asking for shipping cost, they have advantages over e-commerce. Examples ReferencesHow to stop Amazon from killing your store]]></content>
      <categories>
        <category>Business</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读书笔记：《创京东》第一部分 第二章 试水电商]]></title>
    <url>%2F2018%2F03%2F29%2Fjd-s1c2%2F</url>
    <content type="text"><![CDATA[1999年，中国零售业关心线下连锁店，并不关心电商。1999年，中国出现了很多大型连锁超市，例如苏宁和国美。中国零售业重点发展线下连锁店，对电商并不感兴趣。线下连锁店巅峰时期为2004年，国美、苏宁上市，并购其他公司。1999年的同时，互联网电商萌芽。有易趣网，类似于eBay。还有当当网、卓越网，类似于亚马逊。同年马云创建阿里巴巴，聚拢中国外贸商家。而此时，刘强东在研究库存与采购，对电商和互联网并不特别关心。转折点发生在2003年非典时期。这时候客户不愿意见面交易，大量库存堆积如山，京东持续亏损。解决办法是通过网上论坛获取订单，最后成功清理库存，打开光磁市场。这导致刘强东对互联网和电商有了兴趣，开始做独立网站卖产品。]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>创京东</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vertical Integration: AT&T-Time Warner]]></title>
    <url>%2F2018%2F03%2F28%2FVertical-Integration-AT-T-Time-Warner%2F</url>
    <content type="text"><![CDATA[纵向合并 - AT&amp;T和时代华纳Learned about vertical integration in article “Why the AT&amp;T-Time Warner Merger Makes Sense” by MICHAEL J. SANTORELLI from The New York Times. 文章核心思想AT&amp;T和时代华纳合并属于纵向合并，没有垄断的隐患。而政客们却竭力反对。作者提议应该把更多精力放在监管那些领头IT公司，比如谷歌和Facebook。因为他们的影响力大到能影响总统选举，还重新定义了人们交流互动的方式。这些才是真正威胁到行业竞争和消费者权益的。 纵向合并与横向合并的差别 纵向合并是同一制造的价值链上，负责不同层次的业务的公司的合并。（不存在竞争关系） 横向合并是生产相同或相似产品的公司的合并。（以前存在竞争关系）举例 反垄断法保护消费者利益 反垄断法 (Antitrust laws, competition laws) 立法用意：阻止行业领头企业横向兼并，最后形成一家独大的局面(monoply)。保护消费者权益。 AT&amp;T和时代华纳合并是纵向合并。AT&amp;T是美国固定和移动电话服务商(Telecommunications)。时代华纳是娱乐传播集团(Entertainment)，旗下有HBO，CNN等。两个企业属于不同的行业领域，不存在垄断。 参考文章Why the AT&amp;T-Time Warner Merger Makes Sense]]></content>
      <categories>
        <category>Business</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Day 9: Recursion]]></title>
    <url>%2F2018%2F03%2F26%2FDay-9-Recursion%2F</url>
    <content type="text"><![CDATA[Review recursion in Java with examples.Recursion is a method that calls itself. The key points to use a recursion is to identify the base case and the recursive case. Common ExampleFactorial1234567//Calculate N!public int factorial(int n) &#123; if(n == 1) //this is the base case return n; else return n*factorial(n-1); //this is the recursive case&#125; 12input: 3output: 6 (1*2*3) Fibonacci1234567891011public int fibonacci(int n) &#123; //two base cases if(n == 0) return 0; if(n == 1) return 1; //recursive case else return fibonacci(n-1) + fibonacci(n-2);&#125; Bunny Ears12345678910public int bunnyEars2(int bunnies) &#123; if(bunnies == 0) return 0; if(bunnies == 1) return 2; if(bunnies %2 == 0) //even return bunnyEars2(bunnies -1 ) + 3; else return bunnyEars2(bunnies - 1) + 2;&#125; 等差数列 Arithmetic Progression12345678public int triangle(int rows) &#123; if(rows == 0) return 0; if(rows == 1) return 1; else return triangle(rows-1) + rows;&#125; Sum of each digit 各个位数之和123456public int sumDigits(int n) &#123; if(n &lt; 10) return n; else return n%10 + sumDigits(n/10);&#125; Reverse a string123456public static String reverse(String str) &#123; if ((null == str) || (str.length() &lt;= 1)) &#123; return str; &#125; return reverse(str.substring(1)) + str.charAt(0);&#125; Two Methods of String substring(int beginIndex) Returns a new string that is a substring of this string. charAt(int index) Returns the char value at the specified index. Examples 123String input = "String";System.out.println(input.substring(1)); //tringSystem.out.println(input.charAt(0)); //S References:Class StringReversing a String with Recursion in Java]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>30 Days of Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记：《创京东》第一部分 第一章 柜台起家]]></title>
    <url>%2F2018%2F03%2F25%2Fjd-s1c1%2F</url>
    <content type="text"><![CDATA[“正品、低价、好服务”。1998年6月18日, 京东多媒体——京东的前身成立了。 京东多媒体 典型的线下渠道生意：在柜台进货、卖货，先做批发，后转零售。 背景：北京中关村 暴利、混乱、无秩序、充满欺诈和贪腐。…正品与山寨货齐飞。 业务： 前期：婚纱影楼视频编辑的硬件和系统 后期：光磁产品、刻录机和录像带转制系统。70% 卖给中关村各电脑城柜台，30% 经由柜台卖给个人 发展： 2011年，北京中关村太平洋数码城倒闭。京东商城交易额超过300亿元，成为中国自营B2C电商老大。 经验总结]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>创京东</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day 0: Hello World]]></title>
    <url>%2F2018%2F03%2F25%2FDay-0-Hello-World%2F</url>
    <content type="text"><![CDATA[Scanner basic functions. Scanner基础。 Day 0: Hello WorldRead from stdin:1Scanner scan = new Scanner(System.in); Read next:1234scan.next(); // returns the next token of inputscan.hasNext(); // returns true if there is another token of input (false otherwise)scan.nextLine() // returns the next LINE of inputscan.hasNextLine(); // returns true if there is another line of input When finish reading, close it to avoid a resource leak.1scan.close(); Example1234Scanner scan = new Scanner(System.in); // open scannerString s = scan.next(); // read the next token and save it to 's'scan.close(); // close scannerSystem.out.println(s); // print 's' to System.out, followed by a new line Reference: Day 0: Hello, World.]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>30 Days of Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day 1: Data Types]]></title>
    <url>%2F2018%2F03%2F25%2FDay-1-Data-Types%2F</url>
    <content type="text"><![CDATA[Scanner functions and examples. Scanner 注意事项和例子 Day 1: Data Types1. Different data type uses different reading methods.123int a = scan.nextInt(); //read next intdouble b = scan.nextDouble(); //read next doubleString c = scan.nextLine(); //read next line as String 2. nextInt(), nextDouble() methods do not consume \nFor example (This does not work.)12345678910111213int i = 4;double d = 4.0;String s = "HackerRank ";Scanner scan = new Scanner(System.in);/* Read and save an integer, double, and String to your variables.*/int a = scan.nextInt();double b = scan.nextDouble();String c = scan.nextLine();System.out.println(a + i);System.out.println(b + d);System.out.println(s + c); //only print s Input:12355.0test Output:1299.0 It is not able to reach the string input. Because nextInt(); reads the integer, but not the “\n”. Then nextLine() reads “\n”, and treats it as the input for c.The input with \n is1235\n5.0\ntest\n 因为nextInt()读入一个整数，但是不会读入这个整数后面的换行符\n。而这时nextLine()开始读，读到了换行符，这个换行符是之前那个整数后面的换行符。nextLine()继续这一行，发现换行符后面没东西了，所以返回了换行而已，并没有接下去读“test”。Solution:1234//Now each read consumes \nint a = Integer.parseInt(scan.nextLine());double b = Double.parseDouble(scan.nextLine());String c = scan.nextLine(); Summary Different data type uses different reading methods. nextInt(), nextDouble() do not consume \n. Reference:Scanner is skipping nextLine() after using next() or nextFoo()?Day 1: Data Types]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>30 Days of Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day 2: Operators]]></title>
    <url>%2F2018%2F03%2F25%2FDay-2-Operators%2F</url>
    <content type="text"><![CDATA[Math.round() Day 2: OperatorsMath.round() returns a double123double percent = (tip_percent + tax_percent)/100.0;int total = (int)Math.round(meal_cost * (1 + percent));System.out.println("The total meal cost is " + total + " dollars."); To Do: Round to 2 decimals In other languages]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>30 Days of Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day 8: Maps]]></title>
    <url>%2F2018%2F03%2F25%2FDay-8-Maps%2F</url>
    <content type="text"><![CDATA[Functions and examples in Map data structure. Map数据结构常用方法和例子。 Map简单方法存储键值对，一对一对存，而且要保证键的唯一性，无序 添加 12put(K key, V value)，返回这个键对应的原来的值。同样的键，新值会覆盖旧值。putAll(Map&lt;? extends K,? extends V&gt; m) 删除 12clear()remove(Object key) 判断 123containsValue(Object value)containsKey(Object key)isEmpty() 获取 123get(Object key)size()values() !– HashTable：底层是哈希表数据结构，不可以存入null键和null值的情况。该集合是线程同步的，效率低!– HashMap：底层是哈希表数据结构，允许使用null键null值。线程不同步，效率高!– TreeMap：底层是二叉树数据结构，线程不同步，可以给map集合中的键排序Set集合底层使用了Map集合 Demo11234567891011121314151617181920212223242526272829303132import java.util.*;class MapDemo&#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素, 返回这个键对应的原来的值。同样的键，新值会覆盖旧值。 System.out.println("put 01-apple: " + map.put("01", "apple")); //put 01-apple: null System.out.println("put 01-new apple: " + map.put("01", "new apple")); //put 01-new apple: Mike map.put("02", "banana"); map.put("03", "grape"); //判断 System.out.println("containsKey: " + map.containsKey("02")); //return true //获取：可以通过get返回值是否为空来判断键是否存在 System.out.println("get: " + map.get("02")); //return banana System.out.println("get: " + map.get("022")); //return null //获取map中所有的值 Collection&lt;String&gt; coll = map.values(); //删除 System.out.println("remove: " + map.remove("02")); //return banana System.out.println("remove: " + map.remove("022")); //return null //打印 System.out.println(map); //&#123;01=new apple, 03=grape&#125; System.out.println(coll); //[new apple, grape] &#125;&#125; 重点：两种取出方法 entrySet() Returns a Set view of the mappings contained in this map Set&lt;Map.Entry&lt;K,V&gt;&gt; keySet() Returns a Set view of the keys contained in this map. Set 取出所有的键到Set中，通过迭代方式取出所有的键，然后再get获取每一个键对应的值图示keySet()Demo2123456789101112131415161718192021222324252627282930import java.util.*;class MapDemo2&#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put("01", "apple"); map.put("02", "banana"); map.put("03", "grape"); map.put("04", "pear"); //先获取所有键的集合 //Set&lt;键的类型&gt; 集合名字 = map.keySet() Set&lt;String&gt; fruitKeySet = map.keySet(); //获取Set迭代器 Iterator&lt;String&gt; it = fruitKeySet.iterator(); while(it.hasNext())&#123; String key = it.next(); System.out.println("Fruit key: " + key + " "); //Fruit key: 01 Fruit key: 02 Fruit key: 03 Fruit key: 04 //有了键就可以用Map的get()获取值 String value = map.get(key); System.out.println(key + "--" + value); //01--apple 02--banana 03--grape 04--pear &#125; &#125;&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>30 Days of Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Market Size 市场估计问题]]></title>
    <url>%2F2018%2F03%2F19%2FMarket-Size-%E5%B8%82%E5%9C%BA%E4%BC%B0%E8%AE%A1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[讨论市场估计问题中的两个类型：问具体数字；问服务的次数，并分别举例说明运算逻辑和过程。 分类根据这个回答，分为两种问题。 第一种：问具体数字。电商一年卖多少本书？ 第二种：问服务的次数。北京多少加油站？ 公式 第一种问题考虑角度：供应/需求 （Supply/Demand)从需求角度：数量 = 消费人群 × 消费频率 × 单位时间 第二种考虑角度：数量 =（单位时间内）服务的总次数 ÷ 频 举例第一种举例：电商一年大约卖多少本书？公式：书总数量（本）= ①用户总数（人）× ②书数量（本/人/年）× 1（年） 消费人群：电商用户（未知） 消费频率：一位电商用户一年买书的数量（未知） 单位时间：一年（已知） 简单来看：假设电商只有1位用户，这位用户每月买1本书。那么在一年内（12个月），这位用户买了 12 × 1 = 12 本书。也就是说，电商这一年内卖出了12本书，因为它只有这一位用户。（很简单的情况） 分步： 电商有多少用户？① 电商用户总数 = 中国网民总数 x 电商网站的市场比例 中国网民总数 = 7亿 = 7 × 10^8 （人） 假设 电商网站的市场比例 = 30% 则 ① 电商用户总数 = 7 × 10^8 × 30% = 2.1 × 10^8 （人） 一位电商用户一年买书的数量？② 一位电商用户一年买书的数量 = 一位电商用户一月买书的数量 × 12 （月） 假设平均每人每月买0.5本，即两个月买一本（因为现在人们很少买书了╮(╯▽╰)╭） 则 ② 书数量（本/人/年）= 书数量（本/人/月）× 12（月/年）= 0.5 × 12 = 6（本/人/年） 单位时间 = 1 年 结论结合 ①②： 书总数量（本）= 用户总数（人）× 书数量（本/人/年）× 1（年） 书总数量（本）= 2.1 × 10^8 × 6 × 1 = 1.26 × 10^9 （本）即：电商一年大约卖12.6亿本书。 第二种举例：美国有多少加油站？公式：加油站总数（个） = ①（单位时间内）汽车加油总次数（次）÷ ②（单位时间内）每个加油站加油总次数（次/个）简单来看，一天24小时中，假设全国汽车总共加油了10次，每个加油站在这天内总共被使用了5次，那么全国有10 ÷ 5 = 2 个加油站。 分步：以下计算都是在单位时间内，单位时间是10天 单位时间内，全国总共加油多少次？① 汽车加油总次数（次）= 加油次数（次/辆）× 汽车总数（辆） 加油次数（次/辆）：假设一辆车平均10天加一次油。即单位时间 = 10天，加油次数 = 1（次/辆/10天） 汽车总数（辆） 以家庭为单位，汽车总数（辆）= 汽车数量（辆/家）× 家庭数量（家） 假设每家平均1.5辆车。 每5人算一个家庭。美国人口约为3亿，则家庭数量 = 美国人口（人）÷ 5（人/家）= 3 × 10^8 ÷ 5 = 6 × 10^7 （家） 则汽车总数（辆） = 汽车数量（辆/家）× 家庭数量（家）= 1.5 × 6 × 10^7 = 9 × 10^7（辆） 所以：① 汽车加油总次数（次）= 加油次数（次/辆）× 汽车总数（辆）= 1 × 9 × 10^7 = 9 × 10^7（次） 单位时间内，每个加油站加油总次数？意思就是，假设一个加油站里有一台加油机，这台加油机每1小时被使用一次，一天有24小时，那么它这天总共被使用了24次。这个加油站也就被使用了24次。注意使用概率：并不是全国所有加油站都有机会被使用。偏远地区使用频率很低。所以这里假设有每个加油站有80%的概率被光顾。 ② 每个加油站加油总次数（次/个）= 使用概率 × 加油机数量（台/个）× 使用次数（次/台/天） 假设使用概率为80% 假设每个加油站有6台加油机。 假设每3小时一台加油机被使用一次，则一天24小时中这台加油机被使用了8次（24/8=3） 所以 ② 每个加油站加油总次数（次/个）= 使用概率 × 加油机数量（台/个）× 使用次数（次/台/天）= 80% × 6 × 8 = 38.4（次/个/天） 单位时间内，每个加油站加油总次数为38.4 × 10（天）= 384 ≈ 400（次/个） 结论结合 ①②：加油站总数（个） = ①（单位时间内）汽车加油总次数（次）÷ ②（单位时间内）每个加油站加油总次数（次/个）加油站总数（个）= 9 × 10^7 ÷ 400 = 2.25 × 10^5 = 225,000（个）即：美国大约有22.5万个加油站。 ​网上查到资料说美国大概有168,000个加油站（2004），数量级是一致的。Reference: market size 估算的一类问题应该怎么思考？ - 林梓默的回答 - 知乎]]></content>
      <categories>
        <category>Case Study</category>
      </categories>
      <tags>
        <tag>Market Size</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Common Commands]]></title>
    <url>%2F2018%2F03%2F19%2FHexo-Common-Commands%2F</url>
    <content type="text"><![CDATA[Hexo common commands for blog post. Create a new post 创建一个新的文章$ hexo new &quot;new post&quot; View site static 发布前预览$ hexo s Clean cache file 清理缓存（如果修改了格式）$ hexo clean Generate and deploy files 发布hexo g -d]]></content>
  </entry>
</search>
